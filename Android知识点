基础问题相关
1、接口的意义-百度 
1）、重要性：在Java语言中， abstract class 和interface 是支持抽象类定义的两种机制。正是由于这两种机制的存在，才赋予了Java强大的 面向对象能力。
2）、简单、规范性：如果一个项目比较庞大，那么就需要一个能理清所有业务的架构师来定义一些主要的接口，这些接口不仅告诉开发人员你需要实现那些业务，而且也将命名规范限制住了（防止一些开发人员随便命名导致别的程序员无法看明白）。
3）、维护、拓展性：比如有一个类，实现了某个功能，突然有一天，发现这个类满足不了需求了，然后又要重新设计这个类，更糟糕是你可能要放弃这个类，那么其他地方可能有引用他，这样修改起来很麻烦。
如果一开始定义一个接口，把功能放在接口里，然后定义类时实现这个接口，然后只要用这个接口去引用实现它的类就行了，以后要换的话只不过是引用另一个类而已，这样就达到维护、拓展的方便性。比如有个method1的方法，如果用接口，【接口名】 【对象名】=new 【实现接口的类】，这样想用哪个类的对象就可以new哪个对象了，new a（）；就是用a的方法，new b（）就是用b的方法，就和USB接口一样，插什么读什么，就是这个原理。
你要做一个画板程序，其中里面有一个面板类，主要负责绘画功能，然后你就这样定义了这个类。
4）、安全、严密性：接口是实现软件松耦合的重要手段，它描叙了系统对外的所有服务，而不涉及任何具体的实现细节。这样就比较安全、严密一些（一般软件服务商考虑的比较多，jdk中很多方法就是实现了某个接口）。


2、抽象类的意义-百度 
1），为子类提供一个公共的类型；
2），封装子类中重复内容（成员变量和方法）；
3），定义有抽象方法，子类虽然有不同的实现，但该方法的定义是一致的


3、内部类的作用-乐视
1）.内部类可以很好的实现隐藏
 一般的非内部类，是不允许有 private 与protected权限的，但内部类可以
2）．内部类拥有外围类的所有元素的访问权限
3）.可是实现多重继承
4）.可以避免修改接口而实现同一个类中两种同名方法的调用。

4、Java 虚拟机的特性-百度-乐视
1）、移植性
无论是GC还是Hotspot都可以用在任何Java可用的地方。比方说，JRuby可以运行在其他平台上，Rails应用就可以运行在IBM主机上的JRuby上，而且这台IBM主机运行的是CP/CMS。实际上，由于Java和OpenJDK项目的开源，我们正在看到越来越多的平台的衍生，因此JVM的移植性也将越来越棒。
2）、成熟
JVM已有超过15年的历史，在过去的这些年里，许多开发者为它做出了许多贡献，使得它的性能一次又一次地提升，让JVM变得更加稳定、快速和广泛。
3）、覆盖面
JRuby和JVM上的其他语言项目已经被开发者所承认，一个典型的例子是invokedynamic specification (aka JSR292)。JSR越来越配合新的语言，JVM已不再是Java一个人定制规则。JVM正在构建成为类如JRuby等项目的优良平台。

5、哪些情况下的对象会被垃圾回收机制处理掉-美团-小米

1）、所有实例都没有活动线程访问。
2）、没有被其他任何实例访问的循环引用实例。
3）、Java 中有不同的引用类型。判断实例是否符合垃圾收集的条件都依赖于它的引用类型

6、进程和线程的区别-猎豹-美团
简而言之,一个程序至少有一个进程,一个进程至少有一个线程. 
线程的划分尺度小于进程，使得多线程程序的并发性高。
另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.

7、java中==和equals和hashCode的区别-乐视

== ： 该操作符生成的是一个boolean结果，它计算的是操作数的值之间的关系
equals ： Object 的 实例方法，比较两个对象的content是否相同
hashCode ： Object 的 native方法 , 获取对象的哈希值，用于确定该对象在哈希表中的索引位置，它实际上是一个int型整数
equals方法是基类Object中的实例方法，因此对所有继承于Object的类都会有该方法
先比较引用是否相同(是否为同一对象),
再判断类型是否一致（是否为同一类型）,
最后比较内容是否一致

8、HashMap的实现原理-美团
1），先对table的非空检查,为空就初始化
2），对key的非空检查，如果key是null，会被存储到table[0]，因为null的hash值总是0
3），对key的hashCode()做hash，然后再通过indexFor()计算index,这个就是table数组的索引;
4），如果在刚才计算出来的索引位置中table没有元素，直接把Entry对象放在那个索引上
5），如果索引上有元素，然后会进行迭代，在迭代的过程中，会调用equals()方法来检查key的相等性(key.equals(k))，如果这个方法返回true，它就会用当前Entry的value来替换之前的value。如果返回false就一直到Entry->next是null，把当前的Entry对象变成链表的下一个节点
6），如果table的长度超过了loadFactor *current capacity，就要重新resize一个原来长度两倍的HashMap

7），对key进行null检查。如果key是null，table[0]这个位置的元素将被返回。
8），key的hashcode()方法被调用，然后计算hash值。
9），indexFor(hash,table.length)用来计算要获取的Entry对象在table数组中的精确的位置，使用刚才计算的hash值。在获取了table数组的索引之后，会迭代链表，调用equals()方法检查key的相等性，如果equals()方法返回true，get方法返回Entry对象的value，否则，返回null。

10），HashMap中数据是用一个叫table的数组来存的，table的索引在逻辑上叫做“桶”(bucket)，它存储了链表的第一个元素。
11），HashMap有一个叫做Entry的内部类，它用来存储key-value对。table数组存的就是它。Entry用一个next属性实现多个Entry以单向链表存放，插入元素时，如果两条Key落在同一个桶，并且这两条key不equals,后入桶的Entry将next指向桶当前的Entry，否则后入桶的会将前面的给覆盖（确保key的唯一性）;
12），使用HashMap的时候最好使用泛型，如果key放的是自己的对象，最好重写equals()和hashcode()。

哈希表是一个数组+链表的存储结构。HashMap存储结构文字解释：
 table[0] →[index=1,Entry<K,V>] 
 table[1] →[index=2,Entry<K,V>]
  ...
 依次类推


9、string-stringbuffer-stringbuilder区别-小米-乐视-百度
String 字符串常量
StringBuffer 字符串变量（线程安全）
StringBuilder 字符串变量（非线程安全）
String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的
StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：
java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同

10、什么导致线程阻塞-58-美团
1）、线程执行了Thread.sleep(int n)方法，线程放弃CPU，睡眠n毫秒,然后恢复运行。
2）、线程要执行一段同步代码，由于无法获得相关的同步锁，只好进入阻塞状态，等到获得了同步锁，才能恢复运行。
3）、线程执行了一个对象的wait()方法，进入阻塞状态，只有等到其他线程执行了该对象的notify()或notifyAll()方法，才可能将其唤醒。
4）、线程执行I/O操作或进行远程通信时，会因为等待相关的资源而进入阻塞状态。例如，当线程执行System.in.read()方法时，如果用户没有向控制台输入数据，则该线程会一直等读到了用户的输入数据才从read()方法返回。进行远程通信时，在客户程序中，线程在以下情况可能进入阻塞状态。
5）、请求与服务器建立连接时，即当线程执行Socket的带参数的构造方法，或执行Socket的connect()方法时，会进入阻塞状态，直到连接成功，此线程才从Socket的构造方法或connect()方法返回。
6）、线程从Socket的输入流读取数据时，如果没有足够的数据，就会进入阻塞状态，直到读到了足够的数据，或者到达输入流的末尾，或者出现了异常，才从输入流的read()方法返回或异常中断。输入流中有多少数据才算足够呢?这要看线程执行的read()方法的类型。
int read(); 只要输入流中有一个字节，就算足够。
int read(byte[] buff); 只要输入流中的字节数目与参数buff数组的长度相同，就算足够。
String readLine(); 只要输入流中邮一行字符串，就算足够。值得注意的是，InputStream类并没有readLine方法，在过滤流BufferedReader类中才有此方法。
7）、线程向Socket的输出流写一批数据时，可能会进入阻塞状态，等到输出了所有的数据，或者出现异常，才从输出流的write()方法返回或异常中断。
8）、调用Socket的setSoLinger()方法设置了关闭Socket的延迟时间，那么当线程执行Socket的close方法时，会进入阻塞状态，直到底层Socket发送完所有剩余数据，或者超过了setSoLinger()方法设置的延迟时间，才从close()方法返回。

11、多线程同步机制-猎豹

volatile和synchronized的区别
1）、volatile通过变量的可见性，指定线程必须从主存中读取变量的最新值；synchronized通过阻塞线程的方式，只有当前线程能访问该变量，锁定了当前变量。
2）、volatile使用在变量级别；synchronized可以使用在变量、方法、类级别
3）、volatile不会造成线程阻塞；synchronized可能会造成线程阻塞
4）、volatile不能保证原子性；synchronized能保证原子性
5）、volatile标记的变量不会被编译器优化；synchronized标记的变量有可能会被编译器优化（指令重排）


12、ArrayMap对比HashMap
如果hashmap和Arraymap在内存优化方面，肯定会选择ArrayMap,因为ArrayMap占用空间小，但是ArrayMap以时间换空间，速度也是慢了很多。
HashMap内部有一个HashMapEntry[]对象，每一个键值对都存储在这个对象里，当使用put方法添加键值对时，就会new一个HashMapEntry对象
ArrayMap的存储中没有Entry这个东西，他是由两个数组来维护的，mHashes数组中保存的是每一项的HashCode值，mArray中就是键值对，每两个元素代表一个键值对，前面保存key，后面的保存value
添加数据时扩容时的处理不一样
HashMap 是创建一个新的容量是之前二倍的对象，然后将之前的数据移动到新的。
ArrayMap用的是copy数据，所以效率相对要高，ArrayMap提供了数组收缩的功能，在clear或remove后，会重新收缩数组，是否空间，

13、hashmap和hashtable的区别-乐视-小米-360
HashMap 不是线程安全的
HashMap 是 map 接口的实现类，是将键映射到值的对象，其中键和值都是对象，并且不能包含重复键，但可以包含重复值。HashMap 允许 null key 和 null value，而 HashTable 不允许。
HashTable 是线程安全 Collection。
HashMap 是 HashTable 的轻量级实现，他们都完成了Map 接口，主要区别在于 HashMap 允许 null key 和 null value,由于非线程安全，效率上可能高于 Hashtable。
区别如下：
HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。
HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。
HashTable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。
HashTable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步。
Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异


14、容器类之间的区别-乐视-美团

15、抽象类接口区别-360

Android 方面
16、如何导入外部数据库？
17、本地广播和全局广播有什么差别？
18、intentService作用是什么,AIDL解决了什么问题-小米
19、Ubuntu编译安卓系统-百度
20、LaunchMode应用场景-百度-小米-乐视
21、Touch事件传递流程-小米
22、View绘制流程-百度
23、多线程-360
24、Handler,Thread和HandlerThread的差别-小米
25、线程同步-百度
26、什么情况导致内存泄漏-美团
27、ANR定位和修正
28、什么情况导致oom-乐视-美团
29、Service与Activity之间通信的几种方式
30、如何保证service在后台不被Kill
31、Requestlayout,onlayout,onDraw,DrawChild区别与联系-猎豹
32、Android动画框架实现原理
33、Android为每个应用程序分配的内存大小是多少-美团
34、优化自定义view百度-乐视-小米
36、volley-美团-乐视
37、Glide源码解析
38、Android设计模式
39、Android属性动画特性-乐视-小米
40、Activity Window View三者的差别,fragment的特点-360
41、invalidate和postInvalidate的区别及使用-百度
42、LinearLayout和RelativeLayout性能对比-百度
43、View刷新机制-百度-美团
44、架构设计-搜狐

腾讯公司面试题精选
45、2000万个整数，找出第五十大的数字？
46、从网络加载一个10M的图片，说下注意事项
47、自定义View注意事项
48、项目中常用的设计模式
49、JVM的理解

阿里面试题精选
50、进程间通信方式
51、什么是协程
52、内存泄露是怎么回事
53、程序计数器，引到了逻辑地址（虚地址）和物理地址及其映射关系
54、数组和链表的区别
55、二叉树的深度优先遍历和广度优先遍历的具体实现
56、堆的结构
57、bitmap对象的理解
58、什么是深拷贝和浅拷
59、对象锁和类锁是否会互相影响
60、looper架构
61、自定义控件原理
62、自定义控件原理
63、ActivityThread，Ams，Wms的工作原理
64、Java中final，finally，finalize的区别
65、一个文件中有100万个整数，由空格分开，在程序中判断用户输入的整数是否在此文件中。说出最优的方法
66、两个进程同时要求写或者读，能不能实现？如何防止进程的同步？
67、volatile 的意义？
68、烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢？



69、手写代码：大整数加法

70、简历上提到使用Butterknife，Butterknife是什么阶段注解？注解的生命周期了解吗？

71、简历中提到使用Okhttp做网络通讯，说一下Okhttp拦截器

72、Http和Https区别，没有CA证书可以使用Https访问吗

73、TCP在是哪一层的协议，三次握手过程

74、了解什么加密算法，说一说对称加密和非对称加密

75、了解JVM吗，说说垃圾回收机制

76、了解apk的编译过程吗，简单说了一下dex

77、Java中Collection的常用实现类，map的实现类

78、聊聊Hashmap和Hashtable区别

79、Hashmap的底层实现方式，如何解决哈希冲突，除了这种解决方式还有没有其他解决方式

80、很多网站像新浪微博网址都有短地址，如果让你实现怎么做

81、如何判断两个单链表相交

82、如何使用两个或多个栈模拟队列

83、智力题：现在有一个抽奖活动，从8点到10点这段时间会有若干个用户参与抽奖，现在有10个获奖名额，但没有足够大的空间保存所有的数据，要求每个用户等概率中奖，且10点活动截止瞬间开奖。

二面（50分钟）

84、手写代码：删除单链表倒数第x个结点

85、手写代码：z已知，在无序数组中找到两个数x和y，使x+y=z（使用哈希表以空间换时间）

86、有没有看过Handler的源码，当MessageQueue中没有Message会怎么处理

87、说一下线程与进程，android跨进程通讯的方式，自己有没有用过

88、讲一讲AIDL原理

89、Service有几种启动方式，有什么区别

90、activity的声明周期和启动模式，举了一个实际场景问点击back之后的跳转

91、activityA跳转到B过程中A，B的生命周期函数调用顺序

92、自定义View的相关知识
